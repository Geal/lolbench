use super::prelude::*;
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
enum SubCommand {
    #[structopt(name = "dry-run")]
    Plan {
        #[structopt(flatten)]
        bench_opts: RawBenchOpts,
    },
}

fn plan(benches_dir: &Path, bench_opts: BenchOpts, output_dir: &Path) -> Result<()> {
    let plans = Plans::new(benches_dir, bench_opts, output_dir)?;

    info!("Generated new plans:\n\n{:#?}", plans);

    Ok(())
}

impl SubCommand {
    fn exec(self, benches_dir: &Path, overall_output_dir: &Path) -> Result<()> {
        match self {
            SubCommand::Plan { bench_opts } => plan(
                benches_dir,
                BenchOpts::from_raw(bench_opts)?,
                overall_output_dir,
            ),
        }
    }
}

#[derive(Debug, Deserialize, StructOpt, Serialize)]
pub struct RawBenchOpts {
    // TODO(anp): structopt mangles this help message horribly
    /// Selects specific CPUs on which *only* benchmarks will run. Currently only supported when run
    /// as root on Linux. Accepts a pattern of CPU IDs and ID ranges delimited by commas
    /// (e.g. 0,1,2 or 0-2,4). Defaults to none.
    #[structopt(short = "c", long = "cpus")]
    pub cpu_pattern: Option<String>,

    /// If a CPU pattern is set, also ask the kernel to try to relocate kernel tasks off of
    /// benchmark CPUs.
    #[structopt(short = "k", long = "move-kthreads")]
    pub move_kernel_threads: bool,

    // TODO docs
    #[structopt(flatten)]
    pub run_filter: RawBenchFilter,

    // TODO docs
    #[structopt(flatten)]
    pub toolchains: RawToolchainSpec,
}

#[derive(Debug, Deserialize, Serialize, StructOpt)]
pub struct RawToolchainSpec {
    /// Run benchmarks with a single toolchain.
    #[structopt(long = "single-toolchain")]
    single_toolchain: Option<String>,

    /// Run benchmarks with nightlies from a date range.
    #[structopt(long = "start-date")]
    start: Option<NaiveDate>,

    /// Run benchmarks with nightlies from a date range.
    #[structopt(long = "end-date")]
    end: Option<NaiveDate>,
}

impl ToolchainSpec {
    fn from_raw(raw: RawToolchainSpec) -> Result<Self> {
        use self::RawToolchainSpec as RTS;
        Ok(match raw {
            RTS {
                single_toolchain: Some(toolchain),
                start: None,
                end: None,
            } => ToolchainSpec::Single(toolchain),

            RTS {
                single_toolchain: None,
                start: Some(start),
                end: Some(end),
            } => ToolchainSpec::Range(start, end),

            _ => bail!("unsupported toolchain configuration"),
        })
    }
}

#[derive(Debug, Deserialize, Serialize, StructOpt)]
pub struct RawBenchFilter {
    /// Run all benchmarks in the suite.
    #[structopt(long = "all-benches")]
    pub all: bool,

    /// Run the benchmarks assigned to the given runner.
    #[structopt(long = "runner")]
    pub runner: Option<String>,
}

impl BenchOpts {
    pub(crate) fn from_raw(raw: super::cli::RawBenchOpts) -> Result<Self> {
        let filter = BenchFilter::from_raw(raw.run_filter)?;
        let toolchains = ToolchainSpec::from_raw(raw.toolchains)?;

        Ok(if let Some(pattern) = raw.cpu_pattern {
            Self::shielded(
                filter,
                toolchains,
                ShieldSpec::new(pattern, raw.move_kernel_threads)?,
            )
        } else {
            Self::unshielded(filter, toolchains)
        })
    }
}

impl BenchFilter {
    fn from_raw(raw: RawBenchFilter) -> Result<Self> {
        use self::RawBenchFilter as RBF;

        Ok(match raw {
            RBF {
                all: true,
                runner: None,
            } => BenchFilter::All,
            RBF {
                all: false,
                runner: Some(runner),
            } => BenchFilter::Runner(runner),
            _ => bail!("exactly one benchmark filter must be applied at once"),
        })
    }
}

/// Run benchmarks to assess the performance of code generated by Rust toolchains.
#[derive(StructOpt, Debug)]
pub struct Cli {
    #[structopt(subcommand)]
    cmd: SubCommand,

    /// Directory to benchmark sources.
    #[structopt(long = "lol", parse(from_os_str))]
    benches_dir: Option<PathBuf>,

    /// Directory to write build output and analysis results to.
    #[structopt(short = "o", long = "long", parse(from_os_str))]
    output_dir: Option<PathBuf>,
}

impl Cli {
    pub fn exec(self) -> Result<()> {
        let benches_dir = self.benches_dir
            .as_ref()
            .map(Clone::clone)
            .unwrap_or_else(|| ::std::env::current_dir().unwrap().join("benches"));

        let output_dir = self.output_dir
            .unwrap_or_else(|| ::std::env::current_dir().unwrap());

        self.cmd.exec(&benches_dir, &output_dir)
    }
}
