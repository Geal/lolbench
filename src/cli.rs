use super::prelude::*;
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
enum SubCommand {
    #[structopt(name = "dry-run")]
    Plan {
        /// Specify a file to write machine-readable plan file to. Default is to pretty print to
        /// stdout.
        #[structopt(short = "o", long = "output", parse(from_os_str))]
        output_path: Option<PathBuf>,

        #[structopt(flatten)]
        bench_opts: RawBenchOpts,
    },
}

fn plan(benches_dir: &Path, bench_opts: BenchOpts, output_path: Option<PathBuf>) -> Result<()> {
    let plans = Plans::new(benches_dir, bench_opts)?;

    info!("Generated new plans:\n\n{:?}", plans);

    if let Some(output_path) = output_path {
        info!("Writing to {}...", output_path.display());

        plans.write(&output_path)?;

        info!("Done writing!");
    }

    Ok(())
}

impl SubCommand {
    fn exec(self, benches_dir: &Path, _overall_output_dir: &Path) -> Result<()> {
        match self {
            SubCommand::Plan {
                bench_opts,
                output_path,
            } => plan(benches_dir, BenchOpts::from_raw(bench_opts)?, output_path),
        }
    }
}

#[derive(Debug, Deserialize, StructOpt, Serialize)]
pub struct RawBenchOpts {
    // TODO(anp): structopt mangles this help message horribly
    /// Selects specific CPUs on which *only* benchmarks will run. Currently only supported when run
    /// as root on Linux. Accepts a pattern of CPU IDs and ID ranges delimited by commas
    /// (e.g. 0,1,2 or 0-2,4). Defaults to none.
    #[structopt(short = "c", long = "cpus")]
    pub cpu_pattern: Option<String>,

    /// If a CPU pattern is set, also ask the kernel to try to relocate kernel tasks off of
    /// benchmark CPUs.
    #[structopt(short = "k", long = "move-kthreads")]
    pub move_kernel_threads: bool,

    // TODO docs
    #[structopt(flatten)]
    pub run_filter: RawBenchFilter,
}

#[derive(Debug, Deserialize, Serialize, StructOpt)]
pub struct RawToolchainFilter {
    /// Run benchmarks with a single toolchain.
    #[structopt(long = "single-toolchain")]
    single_toolchain: Option<String>,

    /// Run benchmarks with nightlies from a date range.
    #[structopt(long = "start-date")]
    start: NaiveDate,

    /// Run benchmarks with nightlies from a date range.
    #[structopt(long = "end-date")]
    end: NaiveDate,
}

#[derive(Debug, Deserialize, Serialize, StructOpt)]
pub struct RawBenchFilter {
    /// Run all benchmarks in the suite.
    #[structopt(long = "all")]
    pub all: bool,

    /// Run the benchmarks assigned to the given runner.
    #[structopt(long = "runner")]
    pub runner: Option<String>,
}

impl BenchOpts {
    pub(crate) fn from_raw(raw: super::cli::RawBenchOpts) -> Result<Self> {
        let filter = BenchFilter::from_raw(raw.run_filter)?;

        Ok(if let Some(pattern) = raw.cpu_pattern {
            Self::shielded(filter, ShieldSpec::new(pattern, raw.move_kernel_threads)?)
        } else {
            Self::unshielded(filter)
        })
    }
}

impl BenchFilter {
    fn from_raw(raw: RawBenchFilter) -> Result<Self> {
        use self::RawBenchFilter as RBF;

        Ok(match raw {
            RBF {
                all: true,
                runner: None,
            } => BenchFilter::All,
            RBF {
                all: false,
                runner: Some(runner),
            } => BenchFilter::Runner(runner),
            _ => bail!("exactly one benchmark filter must be applied at once"),
        })
    }
}

/// Run benchmarks to assess the performance of code generated by Rust toolchains.
#[derive(StructOpt, Debug)]
pub struct Cli {
    #[structopt(subcommand)]
    cmd: SubCommand,

    /// Directory to benchmark sources.
    #[structopt(long = "lol", parse(from_os_str))]
    benches_dir: Option<PathBuf>,

    /// Directory to write build output and analysis results to.
    #[structopt(short = "o", long = "long", parse(from_os_str))]
    output_dir: Option<PathBuf>,
}

impl Cli {
    pub fn exec(self) -> Result<()> {
        let benches_dir = self.benches_dir
            .as_ref()
            .map(Clone::clone)
            .unwrap_or_else(|| ::std::env::current_dir().unwrap().join("benches"));

        let output_dir = self.output_dir
            .unwrap_or_else(|| ::std::env::current_dir().unwrap());

        self.cmd.exec(&benches_dir, &output_dir)
    }
}
