#[macro_use]
extern crate failure;
#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate structopt;

extern crate byteorder;
extern crate chrono;
extern crate clap;
extern crate criterion;
extern crate glob;
extern crate lolbench_support;
extern crate marky_mark;
extern crate noisy_float;
extern crate ring;
extern crate serde;
extern crate serde_json;
extern crate simple_logger;
extern crate slug;

#[cfg(test)]
#[macro_use]
extern crate proptest;
#[cfg(test)]
extern crate tempfile;

mod collector;
mod cpu_shield;
mod registry;
mod run_plan;
mod storage;
mod toolchain;

use std::path::PathBuf;
use std::{
    collections::{BTreeMap, BTreeSet},
    path::Path,
};

use chrono::{NaiveDate, Utc};
use structopt::StructOpt;

use lolbench_support::*;

pub use self::{collector::*, cpu_shield::*, run_plan::*, storage::*, toolchain::*};

fn main() -> Result<()> {
    simple_logger::init().unwrap();
    Cli::from_args().exec()
}

#[derive(Debug, StructOpt)]
struct Measure {
    // TODO(anp): structopt mangles this help message horribly
    /// Selects specific CPUs on which *only* benchmarks will run. Currently only supported when run
    /// as root on Linux. Accepts a pattern of CPU IDs and ID ranges delimited by commas
    /// (e.g. 0,1,2 or 0-2,4). Defaults to performing no CPU isolation.
    #[structopt(short = "c", long = "cpus")]
    cpu_pattern: Option<String>,

    /// If a CPU pattern is set, also ask the kernel to try to relocate kernel tasks off of
    /// benchmark CPUs.
    #[structopt(short = "k", long = "move-kthreads")]
    move_kernel_threads: bool,

    /// Limit the benchmarks run to those assigned to the given runner.
    #[structopt(long = "runner")]
    runner: Option<String>,

    /// Run benchmarks with a single toolchain.
    #[structopt(long = "single-toolchain")]
    single_toolchain: Option<String>,

    /// Run benchmarks with nightlies starting from a specific.
    #[structopt(long = "nightlies-since")]
    nightlies_since: Option<NaiveDate>,

    /// Path to data directory. Will be created if empty.
    #[structopt(long = "data-dir", parse(from_os_str))]
    data_dir: PathBuf,
}

impl Measure {
    fn run(self) -> Result<()> {
        let toolchains = match self {
            Self {
                single_toolchain: Some(toolchain),
                nightlies_since: None,
                ..
            } => ToolchainSpec::Single(toolchain.clone()),

            Self {
                single_toolchain: None,
                nightlies_since: Some(start),
                ..
            } => ToolchainSpec::Range(start.clone(), Utc::today().naive_utc()),

            _ => bail!("unsupported toolchain configuration"),
        };

        let kthread_on = self.move_kernel_threads;

        let shield_spec = self.cpu_pattern.as_ref().map(move |cpus| ShieldSpec {
            cpu_mask: cpus.to_string(),
            kthread_on,
        });

        let opts = BenchOpts {
            toolchains,
            runner: self.runner.clone(),
            shield_spec,
        };

        measure(opts, &self.data_dir)
    }
}

/// Run benchmarks to assess the performance of code generated by Rust toolchains.
#[derive(StructOpt, Debug)]
pub struct Cli {
    #[structopt(subcommand)]
    cmd: SubCommand,
}

#[derive(Debug, StructOpt)]
enum SubCommand {
    #[structopt(name = "measure")]
    Measure {
        #[structopt(flatten)]
        inner: Measure,
    },
}

impl Cli {
    pub fn exec(self) -> Result<()> {
        match self.cmd {
            SubCommand::Measure { inner } => inner.run(),
        }
    }
}

pub fn measure(opts: BenchOpts, data_dir: &Path) -> Result<()> {
    info!("ensuring data dir {} exists", data_dir.display());
    let collector = Collector::new(data_dir)?;

    info!("cataloging potential builds to run");
    let candidates = opts.enumerate_bench_candidates()?;

    info!(
        "{} possible benchmark plans to run to satisfy provided options, pruning...",
        candidates.len()
    );

    let to_run = collector.compute_builds_needed(&candidates)?;

    info!("{} plans to run after pruning, running...", to_run.len());

    for (toolchain, benches) in to_run {
        info!("running {} benches with {}", benches.len(), toolchain);
        collector.run_benches_with_toolchain(toolchain, &benches)?;
    }

    info!("all done!");

    Ok(())
}

#[derive(Debug, Deserialize, Eq, PartialEq, PartialOrd, Ord, Serialize)]
pub struct BenchOpts {
    pub shield_spec: Option<ShieldSpec>,
    pub runner: Option<String>,
    pub toolchains: ToolchainSpec,
}

impl BenchOpts {
    pub fn enumerate_bench_candidates(&self) -> Result<BTreeMap<Toolchain, BTreeSet<RunPlan>>> {
        let benchmarks = ::registry::get_benches(self.runner.as_ref().map(String::as_str))?;
        let toolchains = self.toolchains.all_of_em();

        let mut plans = BTreeMap::new();

        for toolchain in toolchains {
            let shield = self.shield_spec.as_ref().map(Clone::clone);
            let create_runplan = |benchmark: &Benchmark| {
                let path = benchmark.entrypoint_path.clone();
                RunPlan::new(
                    benchmark.clone(),
                    // TODO(anp): serialize criterion config if we have it
                    None,
                    shield.clone(),
                    toolchain.clone(),
                    path,
                )
            };

            for benchmark in &benchmarks {
                let rp = create_runplan(benchmark)?;
                rp.validate()?;

                // TODO check if we can skip this

                plans
                    .entry(toolchain.clone())
                    .or_insert(BTreeSet::new())
                    .insert(rp);
            }
        }

        Ok(plans)
    }
}

#[derive(Debug, Deserialize, Eq, PartialEq, PartialOrd, Ord, Serialize)]
pub enum ToolchainSpec {
    Single(String),
    Range(NaiveDate, NaiveDate),
}

impl ToolchainSpec {
    fn all_of_em(&self) -> Vec<Toolchain> {
        use ToolchainSpec::*;
        match self {
            Single(s) => vec![Toolchain::from(s)],
            Range(start, end) => {
                let mut current = *start;
                let mut nightlies = Vec::new();

                while current <= *end {
                    nightlies.push(Toolchain::from(&format!("nightly-{}", current)));
                    current = current.succ();
                }

                nightlies
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn toolchain_date_range() {
        let spec = ToolchainSpec::Range(
            NaiveDate::from_ymd(2015, 5, 15),
            NaiveDate::from_ymd(2015, 6, 2),
        );

        macro_rules! lolol {
            ( $( $datefrag:expr, )* ) => {
                vec![
                $(
                    Toolchain::from(concat!("nightly-2015-", $datefrag)),
                )*
                ]
            };
        }

        assert_eq!(
            spec.all_of_em(),
            lolol![
                "05-15", "05-16", "05-17", "05-18", "05-19", "05-20", "05-21", "05-22", "05-23",
                "05-24", "05-25", "05-26", "05-27", "05-28", "05-29", "05-30", "05-31", "06-01",
                "06-02",
            ]
        )
    }
}
